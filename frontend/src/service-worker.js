/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import {
  CacheFirst,
  StaleWhileRevalidate,
  NetworkFirst,
  NetworkOnly
} from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell.
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  ({ request, url }) => {
    if (request.mode !== 'navigate') {
      return false;
    }
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache Strategies

// 1. Static Assets (JS, CSS) - Cache First
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60,
      }),
    ],
  })
);

// 2. Images - Cache First with longer expiration
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 24 * 60 * 60,
      }),
    ],
  })
);

// 3. Fonts - Cache First
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 365 * 24 * 60 * 60,
      }),
    ],
  })
);

// 4. API - Documents List - Stale While Revalidate
registerRoute(
  ({ url }) => url.pathname === '/api/documents',
  new StaleWhileRevalidate({
    cacheName: 'api-documents',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 5 * 60,
      }),
    ],
  })
);

// 5. API - Document Stats - Stale While Revalidate
registerRoute(
  ({ url }) => url.pathname === '/api/documents/stats',
  new StaleWhileRevalidate({
    cacheName: 'api-stats',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 5 * 60,
      }),
    ],
  })
);

// 6. API - Health Check - Network First
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/health'),
  new NetworkFirst({
    cacheName: 'api-health',
    networkTimeoutSeconds: 3,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 1,
        maxAgeSeconds: 60,
      }),
    ],
  })
);

// 7. API - Search Results - Network First with cache fallback (GET only)
registerRoute(
  ({ url, request }) => url.pathname === '/api/search' && request.method === 'GET',
  new NetworkFirst({
    cacheName: 'api-search',
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60,
      }),
    ],
  })
);

// 8. API - Threads - Stale While Revalidate (GET only)
registerRoute(
  ({ url, request }) => (url.pathname === '/api/threads' || url.pathname.startsWith('/api/threads/')) && request.method === 'GET',
  new StaleWhileRevalidate({
    cacheName: 'api-threads',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60,
      }),
    ],
  })
);

// 9. Blazing Search - CacheFirst for ultra-fast responses (POST requests)
registerRoute(
  ({ url, request }) => url.pathname === '/api/blazing/search' && request.method === 'POST',
  new CacheFirst({
    cacheName: 'blazing-search',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200, // Cache up to 200 searches
        maxAgeSeconds: 2 * 60 * 60, // 2 hours
      }),
    ],
  })
);

// 10. Skip caching for SSE/streaming endpoints - let them pass through
registerRoute(
  ({ url }) => url.pathname.includes('/stream') || url.pathname.includes('/agent'),
  new NetworkOnly()
);

// 11. Skip caching for analytics endpoints
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/analytics'),
  new NetworkOnly()
);

// 12. Background Sync for failed uploads
const bgSyncPlugin = new BackgroundSyncPlugin('uploadQueue', {
  maxRetentionTime: 24 * 60,
});

// 13. Upload endpoint with background sync
registerRoute(
  ({ url }) => url.pathname === '/api/upload',
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  'POST'
);

// Handle messages from clients
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Push notifications
self.addEventListener('push', (event) => {
  if (!event.data) return;
  
  const data = event.data.json();
  const options = {
    body: data.body || 'New update available',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: {
      url: data.url || '/'
    },
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title || 'Second Brain', options)
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  const urlToOpen = event.notification.data?.url || '/';
  
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then(clientList => {
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        return self.clients.openWindow(urlToOpen);
      })
  );
});
